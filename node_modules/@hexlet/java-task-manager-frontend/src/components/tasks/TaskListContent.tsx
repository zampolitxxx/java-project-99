import { DragDropContext, OnDragEndResponder } from "@hello-pangea/dnd";
import { Box } from "@mui/material";
import { isEqual } from "lodash";
import { useEffect, useState } from "react";
import { useDataProvider, useListContext } from "react-admin";
import { useMutation } from "react-query";
import type { Task } from ".";
import { TasksByStatus, getTasksByStatus } from ".";
import { MyDataProvider } from "../../dataProvider";
import { TaskColumn } from "./TaskColumn";

export const TaskListContent = () => {
  const { data: unorderedTasks, isLoading, refetch } = useListContext<Task>();
  const dataProvider = useDataProvider<MyDataProvider>();

  const [tasksByStatus, setTasksByStatus] = useState<TasksByStatus>(
    getTasksByStatus([])
  );

  const [taskStatuses, setTaskStatuses] = useState<string[]>([]);

  useEffect(() => {
    if (unorderedTasks) {
      const newTasksByStatus = getTasksByStatus(unorderedTasks);
      if (!isEqual(newTasksByStatus, tasksByStatus)) {
        setTasksByStatus(newTasksByStatus);
        setTaskStatuses(Object.keys(newTasksByStatus));
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [unorderedTasks]);

  const mutation = useMutation<
    void,
    Error,
    {
      source: Parameters<MyDataProvider["updateTaskStatus"]>[0];
      destination: Parameters<MyDataProvider["updateTaskStatus"]>[1];
    }
  >(
    ({ source, destination }) =>
      dataProvider.updateTaskStatus(source, destination),
    { onSettled: () => refetch() }
  );

  if (isLoading) return null;

  const onDragEnd: OnDragEndResponder = (result) => {
    const { destination, source } = result;

    if (!destination) {
      return;
    }

    if (
      destination.droppableId === source.droppableId &&
      destination.index === source.index
    ) {
      return;
    }

    const sourceStatus = source.droppableId as Task["status"];
    const destinationStatus = destination.droppableId as Task["status"];
    const sourceTask = tasksByStatus[sourceStatus][source.index]!;
    const destinationTask = tasksByStatus[destinationStatus][
      destination.index
    ] ?? { status: destinationStatus, index: destination.index + 1 };

    // compute local state change synchronously
    setTasksByStatus(
      updateTaskStatusLocal(
        sourceTask,
        { status: sourceStatus, index: source.index },
        { status: destinationStatus, index: destination.index },
        tasksByStatus
      )
    );

    // trigger the mutation to persist the changes
    mutation.mutateAsync({
      source: sourceTask,
      destination: destinationTask,
    });
  };

  return (
    <DragDropContext onDragEnd={onDragEnd}>
      <Box display="flex">
        {taskStatuses.map((status) => (
          <TaskColumn
            status={status}
            tasks={tasksByStatus[status]}
            key={status}
          />
        ))}
      </Box>
    </DragDropContext>
  );
};

const updateTaskStatusLocal = (
  sourceTask: Task,
  source: { status: Task["status"]; index: number },
  destination: { status: Task["status"]; index: number },
  tasksByStatus: TasksByStatus
) => {
  if (source.status === destination.status) {
    // moving deal inside the same column
    const column = tasksByStatus[source.status];
    column.splice(source.index, 1);
    column.splice(destination.index, 0, sourceTask);
    return {
      ...tasksByStatus,
      [destination.status]: column,
    };
  } else {
    // moving deal across columns
    const sourceColumn = tasksByStatus[source.status];
    const destinationColumn = tasksByStatus[destination.status];
    sourceColumn.splice(source.index, 1);
    destinationColumn.splice(destination.index, 0, sourceTask);
    return {
      ...tasksByStatus,
      [source.status]: sourceColumn,
      [destination.status]: destinationColumn,
    };
  }
};
